RcBox<T> = {
    strong: i64,
    weak: i64,
    +value: T,
}

Rc<T> = {
    +inner: &RcBox<T>,
}

<T> &RcBox<T>:. {
    inc_strong() {
        self.strong = self.strong + i64 1
    }

    dec_strong() {
        self.strong = self.strong - i64 1
    }
}

<T> Rc<T>:: { 
    new(value: T); Rc<T> {
        box: &RcBox<T> = alloc< RcBox<T> >( i64 1 )

        *box = RcBox<T> { strong = i64 1, weak = i64 0, value = value }
        
        rc: Rc<T> = Rc<T> { inner = box }

        ; rc
    }

    default(); Rc<T> {
        ; Rc<T>:new(T:default())
    }
}

<T> &Rc<T>:. { 
    deref(); &T {
        ptr: &T = &self.inner.value
        ; ptr
    }

    to_string(); String {
        ; (*self.deref()).to_string()
    }

    clone(); *Me {
        self.inner.inc_strong()
        ; *self
    }
}

<T> &Rc<T>:. {
    drop() {
        self.inner.dec_strong()

        ? self.inner.strong == i64 0 {
            # destroy the contained object
            self.inner.value.drop()
            free(self.inner)

            # TODO: remove the implicit "strong weak" pointer now that we've
            # destroyed the contents.
            # self.inner().dec_weak();

            # if self.inner().weak() == 0 {
            #     Global.deallocate(self.ptr.cast(), Layout::for_value(self.ptr.as_ref()));
            # }
        }
    }
}
