Vec<T> = {
    +ptr: &T ~ free<T>(self),
    capacity: u64,
    +len: u64,
}

<T> &Vec<T>:. {
    push(val: T) {
        ? self.capacity == u64 0 {
            *self = Vec<T> {
                len = u64 0,
                capacity = u64 4,
                ptr = cast(alloc<T>(u64 4))
            }
        }

        ? self.len >= self.capacity {
            # reallocate memory
            self.capacity = self.capacity * u64 2
            
            new_ptr: &T = alloc<T>(self.capacity)
            memmove<T>(+self.ptr, new_ptr, self.len * size_of<T>())
            free<T>(+self.ptr)
            
            self.ptr = cast(new_ptr)
        }

        ptr: &T = self.ptr.ptr_add(self.len)
        *ptr = val

        self.len = self.len + u64 1
    }
}

<T> Vec<T>:. {
    cast_as_bytes(); Vec<u8> {
        self.len = self.len * size_of<T>()
        self.cap = self.cap * size_of<T>()

        ; cast(self)
    }
}

<T> Vec<T>:: {
    new(); Vec<T> {
        ; Vec<T> {
            len = u64 0,
            capacity = u64 0,
            ptr = cast<u64, &T>(u64 0),
        }
    }

    init_with(len: u64, obj: T); Vec<T> {
        ptr: &T = alloc<T>(len)

        o := 0

        @ o < len {
            *ptr.ptr_add(o) = obj
            
            o = o + 1
        }

        ; Vec<T> {
            len = len,
            capacity = len,
            ptr = ptr,
        }
    }

    with_capacity(cap: u64); Vec<T> {
        ; Vec<T> {
            len = 0,
            capacity = cap,
            ptr = alloc<T>(cap),
        }
    }

    default(); Vec<T> {
        ; Vec<T>:new()
    }
}

<T> &Vec<T>:. {
    drop() {
        free<T>(self.ptr)
    }
}
