Vec<T> = {
    capacity: i64,
    data_loc: &T,
    len: i64,
}

<T> &Vec<T>:. {
    push(val: T) {
        ? self.len == 0 {
            self.write(Vec<T> {
                len = i64 0,
                capacity = i64 4,
                data_loc = alloc<T>(4)
            })
        }

        ? self.len >= self.capacity {
            # reallocate memory
            self.capacity = self.capacity * i64 2

            new_ptr: &T = alloc<T>(self.capacity)
            memmove<T>(self.data_loc, new_ptr, self.len * size_of<T>())

            free_index = i64 0
            @ free_index < self.capacity {
                free<T>(self.data_loc + free_index)

                free_index = free_index + 1
            }

            self.data_loc = new_ptr
        }

        ptr: &T = self.data_loc + self.len
        ptr.write<T>(val)
        
        self.len = self.len + i64 1
    }

    get(index: i64); T {
        ptr: &T = self.data_loc + index
        ; *ptr
    }

    get_ref(index: i64); &T {
        ptr: &T = self.data_loc + index
        ; ptr
    }
}

<T> Vec<T>:: {
    new(); Vec<T> {
        new_vec: Vec<T> = Vec<T> {
            len = i64 0,
            capacity = i64 4,
            data_loc = cast<i64, &T>(i64 0),
        }

        ; new_vec
    }

    default(); Vec<T> {
        ; Vec<T>:new()
    }
}

<T> &Vec<T>:. {
    drop() {
        index = i64 0

        @ index < self.capacity {
            self.get_ref(index).drop()
            free<T>(self.data_loc + index)

            index = index + 1
        }
    }
}
